import './style.css';
var M = Object.defineProperty;
var b = (d, e, t) => e in d ? M(d, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : d[e] = t;
var a = (d, e, t) => (b(d, typeof e != "symbol" ? e + "" : e, t), t);
import * as D from "monaco-editor";
var g = /* @__PURE__ */ ((d) => (d[d.Exist = 0] = "Exist", d[d.Hover = 1] = "Hover", d))(g || {});
const m = D.editor.MouseTargetType, p = D.editor.CursorChangeReason, u = {
  glyphMarginClassName: "monaco-breakpoint"
}, C = {
  glyphMarginClassName: "monaco-hover-breakpoint"
}, L = {
  isWholeLine: !0,
  className: "monaco-line-highlight"
};
class N {
  constructor() {
    a(this, "eventsMap", /* @__PURE__ */ new Map());
  }
  /**
   * @description subscribe event with handler
   * @param event event name
   * @param handler event handler
   */
  on(e, t) {
    let i = this.eventsMap.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.eventsMap.set(e, i)), i.add(t);
  }
  /**
   * @description subscribe event with handler handler one times
   * @param event event name
   * @param handler event handler
   */
  once(e, t) {
    const i = this;
    function o(s) {
      t(s), i.off(e, o);
    }
    this.on(e, o);
  }
  /**
   * @description handler would be excute when emit
   * @param event event name
   * @param args event handler arguments
   */
  emit(e, t) {
    const i = this.eventsMap.get(e);
    if (i)
      for (let o of i)
        o(t);
  }
  /**
   * @description unsubscribe event handler
   * @param event event name
   * @param handler event handler need unsubscribe
   */
  off(e, t) {
    const i = this.eventsMap.get(e);
    i && (e && t ? i.delete(t) : this.eventsMap.delete(e));
  }
}
class v {
  constructor(e) {
    a(this, "preLineCount", 0);
    a(this, "hoverDecorationId", "");
    a(this, "highlightDecorationId", "");
    a(this, "editor", null);
    a(this, "eventEmitter", new N());
    a(this, "isUndoing", !1);
    a(this, "isLineCountChanged", !1);
    a(this, "lineContent", null);
    a(this, "mouseMoveDisposable", null);
    a(this, "mouseDownDisposable", null);
    a(this, "contentChangedDisposable", null);
    a(this, "cursorPositionChangedDisposable", null);
    a(this, "decorationIdAndRangeMap", /* @__PURE__ */ new Map());
    a(this, "lineNumberAndDecorationIdMap", /* @__PURE__ */ new Map());
    if (!(e != null && e.editor))
      throw new Error("Missing 'editor' parameter");
    const { editor: t } = e;
    this.editor = t, this.initMouseEvent(), this.initEditorEvent();
  }
  initMouseEvent() {
    var e, t;
    (e = this.mouseMoveDisposable) == null || e.dispose(), this.mouseMoveDisposable = this.editor.onMouseMove(
      (i) => {
        const o = this.getModel(), { range: s, detail: r, type: n } = this.getMouseEventTarget(i);
        if (r != null && r.isAfterLines) {
          this.removeHoverDecoration();
          return;
        }
        if (o && n === m.GUTTER_GLYPH_MARGIN) {
          this.removeHoverDecoration();
          const h = this.createBreakpointDecoration(
            s,
            g.Hover
          ), l = o.deltaDecorations(
            [],
            [h]
          );
          this.hoverDecorationId = l[0];
        } else
          this.removeHoverDecoration();
      }
    ), (t = this.mouseDownDisposable) == null || t.dispose(), this.mouseDownDisposable = this.editor.onMouseDown(
      (i) => {
        const o = this.getModel(), { type: s, range: r, detail: n, position: h } = this.getMouseEventTarget(i);
        if (o && s === m.GUTTER_GLYPH_MARGIN) {
          if (n.isAfterLines)
            return;
          const l = h.lineNumber, c = this.lineNumberAndDecorationIdMap.get(l);
          c ? this.removeSpecifyDecoration(c, l) : this.createSpecifyDecoration(r);
        }
      }
    );
  }
  initEditorEvent() {
    var e, t;
    this.preLineCount = this.getLineCount(), (e = this.contentChangedDisposable) == null || e.dispose(), this.contentChangedDisposable = this.editor.onDidChangeModelContent((i) => {
      const o = this.getLineCount();
      this.isUndoing = i.isUndoing, this.isLineCountChanged = o !== this.preLineCount, this.preLineCount = o;
    }), (t = this.cursorPositionChangedDisposable) == null || t.dispose(), this.cursorPositionChangedDisposable = this.editor.onDidChangeCursorPosition((i) => {
      const o = this.getModel(), s = this.getAllDecorations();
      if (o && this.isLineCountChanged)
        for (let r of s) {
          const n = r.range, h = this.decorationIdAndRangeMap.get(r.id), c = !(i.reason === p.Paste) && this.isUndoing && n.startLineNumber !== n.endLineNumber;
          if (!this.isUndoing || c) {
            if (n.startLineNumber === n.endLineNumber)
              this.replaceSpecifyLineNumberAndIdMap(n, r);
            else if (h) {
              const f = this.checkIfLineBreakInHead(i, n, h);
              this.removeSpecifyDecoration(r.id, h.startLineNumber), this.createSpecifyDecoration({
                ...n,
                ...f || c ? {
                  startLineNumber: n.endLineNumber,
                  endColumn: o.getLineLength(n.endLineNumber) + 1
                } : {
                  endLineNumber: n.startLineNumber,
                  endColumn: o.getLineLength(n.startLineNumber) + 1
                }
              });
            }
          } else
            n.startLineNumber === n.endLineNumber && this.replaceSpecifyLineNumberAndIdMap(n, r);
        }
      else
        for (let r of s)
          this.decorationIdAndRangeMap.set(r.id, r.range);
      this.removeExtraDecoration(), this.isUndoing = !1, this.isLineCountChanged = !1, this.lineContent = this.getLineContentAtPosition(i.position);
    });
  }
  getModel() {
    var e;
    return (e = this.editor) == null ? void 0 : e.getModel();
  }
  getLineCount() {
    var e;
    return ((e = this.getModel()) == null ? void 0 : e.getLineCount()) ?? 0;
  }
  getMouseEventTarget(e) {
    return { ...e.target };
  }
  getLineDecoration(e) {
    var t, i, o;
    return ((o = (i = (t = this.getModel()) == null ? void 0 : t.getLineDecorations(e)) == null ? void 0 : i.filter(
      (s) => s.options.glyphMarginClassName === u.glyphMarginClassName
    )) == null ? void 0 : o[0]) ?? null;
  }
  getAllDecorations() {
    var e, t;
    return ((t = (e = this.getModel()) == null ? void 0 : e.getAllMarginDecorations()) == null ? void 0 : t.filter(
      (i) => i.options.glyphMarginClassName === u.glyphMarginClassName
    )) ?? [];
  }
  removeHoverDecoration() {
    const e = this.getModel();
    e && this.hoverDecorationId && e.deltaDecorations([this.hoverDecorationId], []), this.hoverDecorationId = "";
  }
  removeHighlightDecoration() {
    const e = this.getModel();
    e && this.highlightDecorationId && e.deltaDecorations([this.highlightDecorationId], []), this.highlightDecorationId = "";
  }
  removeAllDecorations() {
    const e = [], t = this.getModel();
    for (let [i, o] of this.lineNumberAndDecorationIdMap)
      e.push(o);
    t == null || t.deltaDecorations(e, []), this.removeHoverDecoration();
  }
  /**
   * Remove extra decoration after re render new breakpoint decoration,
   * The purpose is to synchronize with decorationIdAndRangeMap & lineNumberAndDecorationIdMap
   */
  removeExtraDecoration() {
    const e = this.getModel(), t = this.getAllDecorations();
    for (let i of t)
      this.decorationIdAndRangeMap.has(i.id) || e == null || e.deltaDecorations([i.id], []);
  }
  removeSpecifyDecoration(e, t) {
    const i = this.getModel();
    i == null || i.deltaDecorations([e], []), this.decorationIdAndRangeMap.delete(e), this.lineNumberAndDecorationIdMap.delete(t), this.emitBreakpointChanged();
  }
  createSpecifyDecoration(e) {
    const t = this.getModel();
    if (t) {
      const i = this.createBreakpointDecoration(
        e,
        g.Exist
      ), o = t.deltaDecorations(
        [],
        [i]
      )[0];
      this.lineNumberAndDecorationIdMap.set(
        e.endLineNumber,
        o
      ), this.emitBreakpointChanged();
      const s = this.getLineDecoration(e.endLineNumber);
      s && this.decorationIdAndRangeMap.set(o, s.range);
    }
  }
  createBreakpointDecoration(e, t) {
    return {
      range: e,
      options: t === g.Exist ? u : C
    };
  }
  replaceSpecifyLineNumberAndIdMap(e, t) {
    for (let [i, o] of this.decorationIdAndRangeMap)
      if (JSON.stringify(o) === JSON.stringify(t.range)) {
        this.decorationIdAndRangeMap.delete(i);
        break;
      }
    this.decorationIdAndRangeMap.set(t.id, t.range);
    for (let [i, o] of this.lineNumberAndDecorationIdMap)
      if (o === t.id) {
        this.lineNumberAndDecorationIdMap.delete(i);
        break;
      }
    this.lineNumberAndDecorationIdMap.set(e.startLineNumber, t.id), this.emitBreakpointChanged();
  }
  /**
   * 
   * @param position monaco.IPosition
   * @param needFullContent if set true, return the full line content from column 1
   * @returns 
   */
  getLineContentAtPosition(e, t = !0) {
    const i = this.getModel();
    if (i) {
      const { lineNumber: o, column: s } = e;
      return i.getValueInRange({
        startLineNumber: o,
        endLineNumber: o,
        startColumn: t ? 1 : s,
        endColumn: i.getLineLength(o) + 1
      }).trim();
    }
    return "";
  }
  /**
   * @description when decoration changed, check if line break in head.
   * @returns Boolean
   */
  checkIfLineBreakInHead(e, t, i) {
    const { reason: o, position: s } = e, r = o === p.Paste, n = this.getLineContentAtPosition(s, !1);
    let h = !r && i.endColumn === t.endColumn && i.startColumn === t.startColumn && i.endLineNumber !== t.endLineNumber && i.startLineNumber === t.startLineNumber;
    return r && n === this.lineContent && (h = !0), h;
  }
  emit(e, t) {
    this.eventEmitter.emit(e, t);
  }
  emitBreakpointChanged() {
    this.emit("breakpointChanged", this.getBreakpoints());
  }
  on(e, t) {
    this.eventEmitter.on(e, t);
  }
  off(e, t) {
    this.eventEmitter.off(e, t);
  }
  /**
   * @description set background highlight for lineNumber
   * @param lineNumber 
   */
  setLineHighlight(e) {
    const t = this.getModel();
    if (t) {
      if (t.getLineCount() < e)
        throw Error("The lineNumber is greater than the total lineNumber");
      this.removeHighlightDecoration();
      const i = t.deltaDecorations([], [{
        options: L,
        range: {
          startLineNumber: e,
          startColumn: 1,
          endLineNumber: e,
          endColumn: 1
        }
      }]);
      this.highlightDecorationId = i[0];
    }
  }
  /**
   * @description remove the exist highlight line
   */
  removeHighlight() {
    this.removeHighlightDecoration();
  }
  /**
   * @returns The set of line numbers where the breakpoint is located
   */
  getBreakpoints() {
    const e = [];
    for (let [t, i] of this.lineNumberAndDecorationIdMap)
      e.push(t);
    return e;
  }
  /**
   * @returns Remove all breakpoints
   */
  clearBreakpoints() {
    this.removeAllDecorations(), this.decorationIdAndRangeMap.clear(), this.lineNumberAndDecorationIdMap.clear();
  }
  dispose() {
    var e, t, i, o;
    this.editor = null, this.preLineCount = 0, this.isUndoing = !1, this.isLineCountChanged = !1, this.removeAllDecorations(), this.removeHoverDecoration(), this.removeHighlightDecoration(), (e = this.mouseMoveDisposable) == null || e.dispose(), (t = this.mouseDownDisposable) == null || t.dispose(), (i = this.contentChangedDisposable) == null || i.dispose(), (o = this.cursorPositionChangedDisposable) == null || o.dispose(), this.decorationIdAndRangeMap.clear(), this.lineNumberAndDecorationIdMap.clear();
  }
}
export {
  v as MonacoBreakpoint
};
