import { __decorate, __param } from 'vscode/external/tslib/tslib.es6.js';
import { StandaloneServices } from 'vscode/vscode/vs/editor/standalone/browser/standaloneServices';
import { SyncDescriptor } from 'vscode/vscode/vs/platform/instantiation/common/descriptors';
import { mkdirp, FileService } from './vscode/src/vs/platform/files/common/fileService.js';
import { ILogService } from 'vscode/vscode/vs/platform/log/common/log.service';
import { InMemoryFileSystemProvider } from 'vscode/vscode/vs/platform/files/common/inMemoryFilesystemProvider';
export { InMemoryFileSystemProvider } from 'vscode/vscode/vs/platform/files/common/inMemoryFilesystemProvider';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { IFileService } from 'vscode/vscode/vs/platform/files/common/files.service';
import { FileType, FilePermission, createFileSystemProviderError, FileSystemProviderErrorCode, FileSystemProviderError } from 'vscode/vscode/vs/platform/files/common/files';
export { FileChangeType, FilePermission, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType } from 'vscode/vscode/vs/platform/files/common/files';
import { Disposable, DisposableStore, toDisposable } from 'vscode/vscode/vs/base/common/lifecycle';
import { extUri, joinPath } from 'vscode/vscode/vs/base/common/resources';
import { Emitter, Event } from 'vscode/vscode/vs/base/common/event';
import { HTMLFileSystemProvider } from 'vscode/vscode/vs/platform/files/browser/htmlFileSystemProvider';
export { HTMLFileSystemProvider } from 'vscode/vscode/vs/platform/files/browser/htmlFileSystemProvider';
import { Schemas } from 'vscode/vscode/vs/base/common/network';
import { IndexedDBFileSystemProvider } from './vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js';
import { IndexedDB } from 'vscode/vscode/vs/base/browser/indexedDB';
export { IndexedDB } from 'vscode/vscode/vs/base/browser/indexedDB';
import { ITelemetryService } from 'vscode/vscode/vs/platform/telemetry/common/telemetry.service';
import { BufferLogger } from 'vscode/vscode/vs/platform/log/common/bufferLog';
import { ITextFileService } from 'vscode/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { BrowserTextFileService } from './vscode/src/vs/workbench/services/textfile/browser/browserTextFileService.js';
import { FilesConfigurationService } from 'vscode/vscode/vs/workbench/services/filesConfiguration/common/filesConfigurationService';
import { IFilesConfigurationService } from 'vscode/vscode/vs/workbench/services/filesConfiguration/common/filesConfigurationService.service';
import { BrowserElevatedFileService } from './vscode/src/vs/workbench/services/files/browser/elevatedFileService.js';
import { IElevatedFileService } from 'vscode/vscode/vs/workbench/services/files/common/elevatedFileService.service';
import { registerServiceInitializePreParticipant, checkServicesNotInitialized } from 'vscode/lifecycle';
import { logsPath } from 'vscode/workbench';
import 'vscode/vscode/vs/workbench/contrib/files/browser/files.contribution._configuration';

class RegisteredFile {
    constructor(uri, readonly) {
        this.uri = uri;
        this.readonly = readonly;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this._onDidRename = new Emitter();
        this.onDidRename = this._onDidRename.event;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.type = FileType.File;
        this.onDidChange(() => {
            this.mtime = Date.now();
        });
    }
    async stats() {
        return {
            ctime: this.ctime,
            mtime: this.mtime,
            size: await this.getSize(),
            type: FileType.File,
            permissions: this.readonly ? FilePermission.Readonly : undefined
        };
    }
    async getSize() {
        return (await this.read()).length;
    }
    async delete() {
        this._onDidDelete.fire();
    }
    async rename(to) {
        const previousUri = this.uri;
        this.uri = to;
        this._onDidRename.fire({ from: previousUri, to });
    }
}
class RegisteredReadOnlyFile extends RegisteredFile {
    constructor(uri, read) {
        super(uri, true);
        this.read = read;
    }
    write() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
}
class RegisteredMemoryFile extends RegisteredFile {
    constructor(uri, content) {
        super(uri, false);
        this.content = content;
    }
    async read() {
        return this.content;
    }
    async write(content) {
        this.content = content;
        this._onDidChange.fire();
    }
}
function addTrailingSlash(uri) {
    if (!uri.endsWith('/')) {
        return uri + '/';
    }
    return uri;
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
class RegisteredFileSystemProvider extends Disposable {
    constructor(readonly) {
        super();
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this.files = new Map();
        this.capabilities = 2  | 1024 ;
        if (readonly) {
            this.capabilities |= 2048 ;
        }
    }
    formatUri(uri) {
        return ( uri.with({ query: null, fragment: null }).toString(true));
    }
    registerFile(file) {
        this.files.set(this.formatUri(file.uri), file);
        this._onDidChangeFile.fire([{
                resource: file.uri,
                type: 1
            }]);
        const disposableStore = new DisposableStore();
        disposableStore.add(toDisposable(() => {
            if (this.files.get(this.formatUri(file.uri)) === file) {
                this.files.delete(this.formatUri(file.uri));
                this._onDidChangeFile.fire([{
                        resource: file.uri,
                        type: 2
                    }]);
            }
        }));
        disposableStore.add(file.onDidDelete(() => {
            disposableStore.dispose();
        }));
        disposableStore.add(file.onDidChange(() => {
            this._onDidChangeFile.fire([{
                    resource: file.uri,
                    type: 0
                }]);
        }));
        disposableStore.add(file.onDidRename(({ from, to }) => {
            if (this.files.get(this.formatUri(from)) === file) {
                this.files.delete(this.formatUri(from));
                this.files.set(this.formatUri(to), file);
                this._onDidChangeFile.fire([{
                        resource: from,
                        type: 2
                    }, {
                        resource: to,
                        type: 1
                    }]);
            }
        }));
        return disposableStore;
    }
    async stat(resource) {
        const resourceUri = this.formatUri(resource);
        const file = this.files.get(resourceUri);
        if (file != null) {
            return file.stats();
        }
        const handledUris = Array.from(( this.files.keys()));
        for (const handledUri of handledUris) {
            if (handledUri.startsWith(addTrailingSlash(resourceUri))) {
                return {
                    ctime: Date.now(),
                    mtime: Date.now(),
                    size: 0,
                    type: FileType.Directory
                };
            }
        }
        throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async readdir(resource) {
        const includedPaths = ( ( Array.from(( this.files.keys()))
            .map(uri => ( URI.parse(uri))))
            .filter(uri => uri.authority === resource.authority && uri.path.startsWith(addTrailingSlash(resource.path)))
            .map(uri => extUri.relativePath(resource, uri)));
        const files = includedPaths.filter(path => !path.includes('/'));
        const directories = ( includedPaths.filter(path => path.includes('/')).map(path => path.slice(0, path.indexOf('/'))));
        return [
            ...( files.map(path => [
                path,
                FileType.File
            ])),
            ...( directories.map(path => [
                path,
                FileType.Directory
            ]))
        ];
    }
    async readFile(resource) {
        const file = this.files.get(this.formatUri(resource));
        if (file != null) {
            const data = await file.read();
            if (data instanceof Uint8Array) {
                return data;
            }
            else {
                return encoder.encode(data);
            }
        }
        throw FileSystemProviderError.create('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    watch() {
        return Disposable.None;
    }
    async writeFile(resource, content) {
        const file = this.files.get(this.formatUri(resource));
        if (file?.write != null) {
            await file.write(decoder.decode(content));
            return;
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async delete(resource) {
        const file = this.files.get(this.formatUri(resource));
        if (file != null) {
            await file.delete();
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async rename(from, to) {
        const file = this.files.get(this.formatUri(from));
        if (file != null) {
            await file.rename(to);
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async mkdir() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
}
function isFullfiled(result) {
    return result.status === 'fulfilled';
}
class OverlayFileSystemProvider {
    constructor() {
        this.providers = [];
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._onDidChangeOverlays = new Emitter();
        this.onDidChangeOverlays = this._onDidChangeOverlays.event;
        this.capabilities = 2  | 1024 ;
    }
    register(priority, provider) {
        const item = { priority, provider };
        this.providers.push(item);
        this.providers.sort((a, b) => b.priority - a.priority);
        const disposableStore = new DisposableStore();
        disposableStore.add(provider.onDidChangeFile(e => {
            this._onDidChangeFile.fire(e);
        }));
        disposableStore.add({
            dispose: () => {
                const index = this.providers.indexOf(item);
                if (index >= 0) {
                    this.providers.splice(index, 1);
                    this._onDidChangeOverlays.fire();
                }
            }
        });
        this._onDidChangeOverlays.fire();
        return disposableStore;
    }
    get delegates() {
        return ( this.providers.map(({ provider }) => provider));
    }
    async readFromDelegates(caller) {
        if (this.delegates.length === 0) {
            throw createFileSystemProviderError('No delegate', FileSystemProviderErrorCode.Unavailable);
        }
        let firstError;
        for (const delegate of this.delegates) {
            try {
                return await caller(delegate);
            }
            catch (err) {
                firstError ?? (firstError = err);
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw firstError;
    }
    async writeToDelegates(caller) {
        if (this.delegates.length === 0) {
            throw createFileSystemProviderError('No delegate', FileSystemProviderErrorCode.Unavailable);
        }
        for (const provider of this.delegates) {
            if (((provider.capabilities & 2048) ) > 0) {
                continue;
            }
            try {
                return await caller(provider);
            }
            catch (err) {
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async stat(resource) {
        return this.readFromDelegates(async (delegate) => {
            const result = await delegate.stat(resource);
            const readOnly = ((delegate.capabilities & 2048) ) > 0;
            return {
                ...result,
                permissions: result.permissions ?? (readOnly ? FilePermission.Readonly : undefined)
            };
        });
    }
    async readFile(resource) {
        return this.readFromDelegates(delegate => delegate.readFile(resource));
    }
    async readdir(resource) {
        const results = await Promise.allSettled(( this.delegates.map(async (delegate) => delegate.readdir(resource))));
        if (!( results.some(isFullfiled))) {
            throw results[0].reason;
        }
        return Object.entries(Object.fromEntries(( results.filter(isFullfiled).map(result => result.value)).flat()));
    }
    watch(resource, opts) {
        const store = new DisposableStore();
        for (const delegate of this.delegates) {
            store.add(delegate.watch(resource, opts));
        }
        return store;
    }
    async writeFile(resource, content, opts) {
        await this.writeToDelegates(async (delegate) => {
            let stats;
            try {
                stats = await delegate.stat(resource);
            }
            catch (err) {
            }
            if (stats != null && ((stats.permissions ?? 0) & FilePermission.Readonly) > 0) {
                throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
            }
            return delegate.writeFile(resource, content, opts);
        });
    }
    async mkdir(resource) {
        await this.writeToDelegates(delegate => delegate.mkdir(resource));
    }
    async delete(resource, opts) {
        await this.writeToDelegates(delegate => delegate.delete(resource, opts));
    }
    async rename(from, to, opts) {
        await this.writeToDelegates(delegate => delegate.rename(from, to, opts));
    }
}
class MkdirpOnWriteInMemoryFileSystemProvider extends InMemoryFileSystemProvider {
    async writeFile(resource, content, opts) {
        await mkdirp(extUri, this, extUri.dirname(resource));
        return super.writeFile(resource, content, opts);
    }
}
class DelegateFileSystemProvider {
    constructor(options) {
        this.options = options;
        this.onDidChangeCapabilities = this.options.delegate.onDidChangeCapabilities;
        this.onDidChangeFile = ( Event.map(this.options.delegate.onDidChangeFile, changes => ( changes.map(change => ({
            type: change.type,
            resource: this.options.fromDeletate(change.resource)
        })))));
        this.readFile = this.options.delegate.readFile != null
            ? (resource) => {
                return this.options.delegate.readFile(this.options.toDelegate(resource));
            }
            : undefined;
        this.writeFile = this.options.delegate.writeFile != null
            ? (resource, content, opts) => {
                return this.options.delegate.writeFile(this.options.toDelegate(resource), content, opts);
            }
            : undefined;
    }
    get capabilities() { return this.options.delegate.capabilities; }
    watch(resource, opts) {
        return this.options.delegate.watch(this.options.toDelegate(resource), opts);
    }
    stat(resource) {
        return this.options.delegate.stat(this.options.toDelegate(resource));
    }
    mkdir(resource) {
        return this.options.delegate.mkdir(this.options.toDelegate(resource));
    }
    readdir(resource) {
        return this.options.delegate.readdir(this.options.toDelegate(resource));
    }
    delete(resource, opts) {
        return this.options.delegate.delete(this.options.toDelegate(resource), opts);
    }
    rename(from, to, opts) {
        return this.options.delegate.rename(this.options.toDelegate(from), this.options.toDelegate(to), opts);
    }
}
class EmptyFileSystemProvider {
    constructor() {
        this.capabilities = 2  | 1024 ;
        this.onDidChangeCapabilities = Event.None;
        this.onDidChangeFile = Event.None;
    }
    async readFile() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async writeFile() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    watch() {
        return Disposable.None;
    }
    async stat() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async mkdir() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async readdir() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
}
const overlayFileSystemProvider = new OverlayFileSystemProvider();
overlayFileSystemProvider.register(0, new MkdirpOnWriteInMemoryFileSystemProvider());
const extensionFileSystemProvider = new RegisteredFileSystemProvider(true);
const userDataFileSystemProvider = new InMemoryFileSystemProvider();
void userDataFileSystemProvider.mkdir(( URI.from({ scheme: Schemas.vscodeUserData, path: '/User/' })));
var CustomSchemas;
( (function(CustomSchemas) {
    CustomSchemas.extensionFile = 'extension-file';
})(CustomSchemas || (CustomSchemas = {})));
const providers = {
    [CustomSchemas.extensionFile]: extensionFileSystemProvider,
    [logsPath.scheme]: new InMemoryFileSystemProvider(),
    [Schemas.vscodeUserData]: userDataFileSystemProvider,
    [Schemas.tmp]: new InMemoryFileSystemProvider(),
    [Schemas.file]: overlayFileSystemProvider
};
let FileServiceOverride = class FileServiceOverride extends FileService {
    constructor(logService, telemetryService) {
        super(logService);
        for (const [scheme, provider] of Object.entries(providers)) {
            let disposable = this.registerProvider(scheme, provider);
            if (provider instanceof OverlayFileSystemProvider) {
                provider.onDidChangeOverlays(() => {
                    disposable.dispose();
                    disposable = this.registerProvider(scheme, provider);
                });
            }
            if (provider instanceof IndexedDBFileSystemProvider) {
                this._register(provider.onReportError(e => telemetryService.publicLog2('indexedDBFileSystemProviderError', e)));
            }
        }
    }
};
FileServiceOverride = __decorate([
    ( __param(1, ITelemetryService))
], FileServiceOverride);
const fileLogger = new BufferLogger();
registerServiceInitializePreParticipant(async (accessor) => {
    fileLogger.logger = accessor.get(ILogService);
});
function getServiceOverride() {
    return {
        [( IFileService.toString())]: new SyncDescriptor(FileServiceOverride, [fileLogger], true),
        [( ITextFileService.toString())]: new SyncDescriptor(BrowserTextFileService, [], true),
        [( IFilesConfigurationService.toString())]: new SyncDescriptor(FilesConfigurationService, [], true),
        [( IElevatedFileService.toString())]: new SyncDescriptor(BrowserElevatedFileService, [], true)
    };
}
function registerCustomProvider(scheme, provider) {
    checkServicesNotInitialized();
    providers[scheme] = provider;
}
function registerExtensionFile(extensionLocation, filePath, getContent) {
    return extensionFileSystemProvider.registerFile(new RegisteredReadOnlyFile(joinPath(extensionLocation, filePath), getContent));
}
async function initFile(file, content, options) {
    checkServicesNotInitialized();
    const provider = providers[file.scheme];
    if (provider == null || provider.writeFile == null) {
        throw new Error(`${file.scheme} provider doesn't exist or doesn't support writing files`);
    }
    if (!(options?.overwrite ?? false)) {
        try {
            await provider.stat(file);
            return;
        }
        catch (error) {
        }
    }
    await provider.writeFile(file, content instanceof Uint8Array ? content : encoder.encode(content), {
        atomic: false,
        create: true,
        overwrite: false,
        unlock: false,
        ...options
    });
}
let indexedDB;
const userDataStore = 'vscode-userdata-store';
const logsStore = 'vscode-logs-store';
const handlesStore = 'vscode-filehandles-store';
async function createIndexedDBProviders() {
    indexedDB = await IndexedDB.create('vscode-web-db', 3, [userDataStore, logsStore, handlesStore]);
    registerCustomProvider(logsPath.scheme, new IndexedDBFileSystemProvider(logsPath.scheme, indexedDB, logsStore, false));
    const userDataProvider = new IndexedDBFileSystemProvider(Schemas.vscodeUserData, indexedDB, userDataStore, true);
    registerCustomProvider(Schemas.vscodeUserData, userDataProvider);
    return userDataProvider;
}
function registerHTMLFileSystemProvider() {
    class LazyLogService {
        get onDidChangeLogLevel() {
            return StandaloneServices.get(ILogService).onDidChangeLogLevel;
        }
        getLevel() {
            return StandaloneServices.get(ILogService).getLevel();
        }
        setLevel(level) {
            StandaloneServices.get(ILogService).setLevel(level);
        }
        trace(message, ...args) {
            StandaloneServices.get(ILogService).trace(message, ...args);
        }
        debug(message, ...args) {
            StandaloneServices.get(ILogService).debug(message, ...args);
        }
        info(message, ...args) {
            StandaloneServices.get(ILogService).info(message, ...args);
        }
        warn(message, ...args) {
            StandaloneServices.get(ILogService).warn(message, ...args);
        }
        error(message, ...args) {
            StandaloneServices.get(ILogService).error(message, ...args);
        }
        flush() {
            StandaloneServices.get(ILogService).flush();
        }
        dispose() {
            StandaloneServices.get(ILogService).dispose();
        }
    }
    registerCustomProvider(Schemas.file, new HTMLFileSystemProvider(indexedDB, handlesStore, new LazyLogService()));
}
function registerFileSystemOverlay(priority, provider) {
    const overlayProvider = providers.file;
    if (!(overlayProvider instanceof OverlayFileSystemProvider)) {
        throw new Error('The overlay filesystem provider was replaced');
    }
    return overlayProvider.register(priority, provider);
}

export { CustomSchemas, DelegateFileSystemProvider, EmptyFileSystemProvider, IndexedDBFileSystemProvider, OverlayFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, createIndexedDBProviders, getServiceOverride as default, initFile, registerCustomProvider, registerExtensionFile, registerFileSystemOverlay, registerHTMLFileSystemProvider };
