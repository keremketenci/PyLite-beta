{
  "version": 3,
  "sources": ["../../@radix-ui/react-menu/dist/packages/react/menu/src/index.ts", "../../@radix-ui/react-menu/dist/packages/react/menu/src/Menu.tsx", "../../@radix-ui/react-menubar/dist/packages/react/menubar/src/index.ts", "../../@radix-ui/react-menubar/dist/packages/react/menubar/src/Menubar.tsx"],
  "sourcesContent": ["export {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n} from './Menu';\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n} from './Menu';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus();\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n", "export {\n  createMenubarScope,\n  //\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarPortal,\n  MenubarContent,\n  MenubarGroup,\n  MenubarLabel,\n  MenubarItem,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarItemIndicator,\n  MenubarSeparator,\n  MenubarArrow,\n  MenubarSub,\n  MenubarSubTrigger,\n  MenubarSubContent,\n  //\n  Root,\n  Menu,\n  Trigger,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n} from './Menubar';\nexport type {\n  MenubarProps,\n  MenubarMenuProps,\n  MenubarTriggerProps,\n  MenubarPortalProps,\n  MenubarContentProps,\n  MenubarGroupProps,\n  MenubarLabelProps,\n  MenubarItemProps,\n  MenubarCheckboxItemProps,\n  MenubarRadioGroupProps,\n  MenubarRadioItemProps,\n  MenubarItemIndicatorProps,\n  MenubarSeparatorProps,\n  MenubarArrowProps,\n  MenubarSubProps,\n  MenubarSubTriggerProps,\n  MenubarSubContentProps,\n} from './Menubar';\n", "import * as React from 'react';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport * as MenuPrimitive from '@radix-ui/react-menu';\nimport { createMenuScope } from '@radix-ui/react-menu';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type { Scope } from '@radix-ui/react-context';\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * Menubar\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENUBAR_NAME = 'Menubar';\n\ntype ItemData = { value: string; disabled: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenubarTriggerElement,\n  ItemData\n>(MENUBAR_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenubar?: Scope };\nconst [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [\n  createCollectionScope,\n  createRovingFocusGroupScope,\n]);\n\nconst useMenuScope = createMenuScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenubarContextValue = {\n  value: string;\n  dir: Direction;\n  loop: boolean;\n  onMenuOpen(value: string): void;\n  onMenuClose(): void;\n  onMenuToggle(value: string): void;\n};\n\nconst [MenubarContextProvider, useMenubarContext] =\n  createMenubarContext<MenubarContextValue>(MENUBAR_NAME);\n\ntype MenubarElement = React.ElementRef<typeof Primitive.div>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenubarProps extends PrimitiveDivProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  loop?: RovingFocusGroupProps['loop'];\n  dir?: RovingFocusGroupProps['dir'];\n}\n\nconst Menubar = React.forwardRef<MenubarElement, MenubarProps>(\n  (props: ScopedProps<MenubarProps>, forwardedRef) => {\n    const {\n      __scopeMenubar,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      loop = true,\n      dir,\n      ...menubarProps\n    } = props;\n    const direction = useDirection(dir);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenubar);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue,\n    });\n\n    // We need to manage tab stop id manually as `RovingFocusGroup` updates the stop\n    // based on focus, and in some situations our triggers won't ever be given focus\n    // (e.g. click to open and then outside to close)\n    const [currentTabStopId, setCurrentTabStopId] = React.useState<string | null>(null);\n\n    return (\n      <MenubarContextProvider\n        scope={__scopeMenubar}\n        value={value}\n        onMenuOpen={React.useCallback(\n          (value) => {\n            setValue(value);\n            setCurrentTabStopId(value);\n          },\n          [setValue]\n        )}\n        onMenuClose={React.useCallback(() => setValue(''), [setValue])}\n        onMenuToggle={React.useCallback(\n          (value) => {\n            setValue((prevValue) => (Boolean(prevValue) ? '' : value));\n            // `openMenuOpen` and `onMenuToggle` are called exclusively so we\n            // need to update the id in either case.\n            setCurrentTabStopId(value);\n          },\n          [setValue]\n        )}\n        dir={direction}\n        loop={loop}\n      >\n        <Collection.Provider scope={__scopeMenubar}>\n          <Collection.Slot scope={__scopeMenubar}>\n            <RovingFocusGroup.Root\n              asChild\n              {...rovingFocusGroupScope}\n              orientation=\"horizontal\"\n              loop={loop}\n              dir={direction}\n              currentTabStopId={currentTabStopId}\n              onCurrentTabStopIdChange={setCurrentTabStopId}\n            >\n              <Primitive.div role=\"menubar\" {...menubarProps} ref={forwardedRef} />\n            </RovingFocusGroup.Root>\n          </Collection.Slot>\n        </Collection.Provider>\n      </MenubarContextProvider>\n    );\n  }\n);\n\nMenubar.displayName = MENUBAR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'MenubarMenu';\n\ntype MenubarMenuContextValue = {\n  value: string;\n  triggerId: string;\n  triggerRef: React.RefObject<MenubarTriggerElement>;\n  contentId: string;\n  wasKeyboardTriggerOpenRef: React.MutableRefObject<boolean>;\n};\n\nconst [MenubarMenuProvider, useMenubarMenuContext] =\n  createMenubarContext<MenubarMenuContextValue>(MENU_NAME);\n\ninterface MenubarMenuProps {\n  value?: string;\n  children?: React.ReactNode;\n}\n\nconst MenubarMenu = (props: ScopedProps<MenubarMenuProps>) => {\n  const { __scopeMenubar, value: valueProp, ...menuProps } = props;\n  const autoValue = useId();\n  // We need to provide an initial deterministic value as `useId` will return\n  // empty string on the first render and we don't want to match our internal \"closed\" value.\n  const value = valueProp || autoValue || 'LEGACY_REACT_AUTO_VALUE';\n  const context = useMenubarContext(MENU_NAME, __scopeMenubar);\n  const menuScope = useMenuScope(__scopeMenubar);\n  const triggerRef = React.useRef<MenubarTriggerElement>(null);\n  const wasKeyboardTriggerOpenRef = React.useRef(false);\n  const open = context.value === value;\n\n  React.useEffect(() => {\n    if (!open) wasKeyboardTriggerOpenRef.current = false;\n  }, [open]);\n\n  return (\n    <MenubarMenuProvider\n      scope={__scopeMenubar}\n      value={value}\n      triggerId={useId()}\n      triggerRef={triggerRef}\n      contentId={useId()}\n      wasKeyboardTriggerOpenRef={wasKeyboardTriggerOpenRef}\n    >\n      <MenuPrimitive.Root\n        {...menuScope}\n        open={open}\n        onOpenChange={(open) => {\n          // Menu only calls `onOpenChange` when dismissing so we\n          // want to close our MenuBar based on the same events.\n          if (!open) context.onMenuClose();\n        }}\n        modal={false}\n        dir={context.dir}\n        {...menuProps}\n      />\n    </MenubarMenuProvider>\n  );\n};\n\nMenubarMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'MenubarTrigger';\n\ntype MenubarTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface MenubarTriggerProps extends PrimitiveButtonProps {}\n\nconst MenubarTrigger = React.forwardRef<MenubarTriggerElement, MenubarTriggerProps>(\n  (props: ScopedProps<MenubarTriggerProps>, forwardedRef) => {\n    const { __scopeMenubar, disabled = false, ...triggerProps } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenubar);\n    const menuScope = useMenuScope(__scopeMenubar);\n    const context = useMenubarContext(TRIGGER_NAME, __scopeMenubar);\n    const menuContext = useMenubarMenuContext(TRIGGER_NAME, __scopeMenubar);\n    const ref = React.useRef<MenubarTriggerElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, menuContext.triggerRef);\n    const [isFocused, setIsFocused] = React.useState(false);\n    const open = context.value === menuContext.value;\n\n    return (\n      <Collection.ItemSlot scope={__scopeMenubar} value={menuContext.value} disabled={disabled}>\n        <RovingFocusGroup.Item\n          asChild\n          {...rovingFocusGroupScope}\n          focusable={!disabled}\n          tabStopId={menuContext.value}\n        >\n          <MenuPrimitive.Anchor asChild {...menuScope}>\n            <Primitive.button\n              type=\"button\"\n              role=\"menuitem\"\n              id={menuContext.triggerId}\n              aria-haspopup=\"menu\"\n              aria-expanded={open}\n              aria-controls={open ? menuContext.contentId : undefined}\n              data-highlighted={isFocused ? '' : undefined}\n              data-state={open ? 'open' : 'closed'}\n              data-disabled={disabled ? '' : undefined}\n              disabled={disabled}\n              {...triggerProps}\n              ref={composedRefs}\n              onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n                // but not when the control key is pressed (avoiding MacOS right click)\n                if (!disabled && event.button === 0 && event.ctrlKey === false) {\n                  context.onMenuOpen(menuContext.value);\n                  // prevent trigger focusing when opening\n                  // this allows the content to be given focus without competition\n                  if (!open) event.preventDefault();\n                }\n              })}\n              onPointerEnter={composeEventHandlers(props.onPointerEnter, () => {\n                const menubarOpen = Boolean(context.value);\n                if (menubarOpen && !open) {\n                  context.onMenuOpen(menuContext.value);\n                  ref.current?.focus();\n                }\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                if (disabled) return;\n                if (['Enter', ' '].includes(event.key)) context.onMenuToggle(menuContext.value);\n                if (event.key === 'ArrowDown') context.onMenuOpen(menuContext.value);\n                // prevent keydown from scrolling window / first focused item to execute\n                // that keydown (inadvertently closing the menu)\n                if (['Enter', ' ', 'ArrowDown'].includes(event.key)) {\n                  menuContext.wasKeyboardTriggerOpenRef.current = true;\n                  event.preventDefault();\n                }\n              })}\n              onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n              onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n            />\n          </MenuPrimitive.Anchor>\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nMenubarTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenubarPortal';\n\ntype MenuPortalProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Portal>;\ninterface MenubarPortalProps extends MenuPortalProps {}\n\nconst MenubarPortal: React.FC<MenubarPortalProps> = (props: ScopedProps<MenubarPortalProps>) => {\n  const { __scopeMenubar, ...portalProps } = props;\n  const menuScope = useMenuScope(__scopeMenubar);\n  return <MenuPrimitive.Portal {...menuScope} {...portalProps} />;\n};\n\nMenubarPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenubarContent';\n\ntype MenubarContentElement = React.ElementRef<typeof MenuPrimitive.Content>;\ntype MenuContentProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Content>;\ninterface MenubarContentProps extends Omit<MenuContentProps, 'onEntryFocus'> {}\n\nconst MenubarContent = React.forwardRef<MenubarContentElement, MenubarContentProps>(\n  (props: ScopedProps<MenubarContentProps>, forwardedRef) => {\n    const { __scopeMenubar, align = 'start', ...contentProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    const context = useMenubarContext(CONTENT_NAME, __scopeMenubar);\n    const menuContext = useMenubarMenuContext(CONTENT_NAME, __scopeMenubar);\n    const getItems = useCollection(__scopeMenubar);\n    const hasInteractedOutsideRef = React.useRef(false);\n\n    return (\n      <MenuPrimitive.Content\n        id={menuContext.contentId}\n        aria-labelledby={menuContext.triggerId}\n        data-radix-menubar-content=\"\"\n        {...menuScope}\n        {...contentProps}\n        ref={forwardedRef}\n        align={align}\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          const menubarOpen = Boolean(context.value);\n          if (!menubarOpen && !hasInteractedOutsideRef.current) {\n            menuContext.triggerRef.current?.focus();\n          }\n\n          hasInteractedOutsideRef.current = false;\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        })}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          const target = event.target as HTMLElement;\n          const isMenubarTrigger = getItems().some((item) => item.ref.current?.contains(target));\n          if (isMenubarTrigger) event.preventDefault();\n        })}\n        onInteractOutside={composeEventHandlers(props.onInteractOutside, () => {\n          hasInteractedOutsideRef.current = true;\n        })}\n        onEntryFocus={(event) => {\n          if (!menuContext.wasKeyboardTriggerOpenRef.current) event.preventDefault();\n        }}\n        onKeyDown={composeEventHandlers(\n          props.onKeyDown,\n          (event) => {\n            if (['ArrowRight', 'ArrowLeft'].includes(event.key)) {\n              const target = event.target as HTMLElement;\n              const targetIsSubTrigger = target.hasAttribute('data-radix-menubar-subtrigger');\n              const isKeyDownInsideSubMenu =\n                target.closest('[data-radix-menubar-content]') !== event.currentTarget;\n\n              const prevMenuKey = context.dir === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n              const isPrevKey = prevMenuKey === event.key;\n              const isNextKey = !isPrevKey;\n\n              // Prevent navigation when we're opening a submenu\n              if (isNextKey && targetIsSubTrigger) return;\n              // or we're inside a submenu and are moving backwards to close it\n              if (isKeyDownInsideSubMenu && isPrevKey) return;\n\n              const items = getItems().filter((item) => !item.disabled);\n              let candidateValues = items.map((item) => item.value);\n              if (isPrevKey) candidateValues.reverse();\n\n              const currentIndex = candidateValues.indexOf(menuContext.value);\n\n              candidateValues = context.loop\n                ? wrapArray(candidateValues, currentIndex + 1)\n                : candidateValues.slice(currentIndex + 1);\n\n              const [nextValue] = candidateValues;\n              if (nextValue) context.onMenuOpen(nextValue);\n            }\n          },\n          { checkForDefaultPrevented: false }\n        )}\n        style={{\n          ...props.style,\n          // re-namespace exposed content custom properties\n          ...{\n            '--radix-menubar-content-transform-origin': 'var(--radix-popper-transform-origin)',\n            '--radix-menubar-content-available-width': 'var(--radix-popper-available-width)',\n            '--radix-menubar-content-available-height': 'var(--radix-popper-available-height)',\n            '--radix-menubar-trigger-width': 'var(--radix-popper-anchor-width)',\n            '--radix-menubar-trigger-height': 'var(--radix-popper-anchor-height)',\n          },\n        }}\n      />\n    );\n  }\n);\n\nMenubarContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenubarGroup';\n\ntype MenubarGroupElement = React.ElementRef<typeof MenuPrimitive.Group>;\ntype MenuGroupProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Group>;\ninterface MenubarGroupProps extends MenuGroupProps {}\n\nconst MenubarGroup = React.forwardRef<MenubarGroupElement, MenubarGroupProps>(\n  (props: ScopedProps<MenubarGroupProps>, forwardedRef) => {\n    const { __scopeMenubar, ...groupProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.Group {...menuScope} {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenubarLabel';\n\ntype MenubarLabelElement = React.ElementRef<typeof MenuPrimitive.Label>;\ntype MenuLabelProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Label>;\ninterface MenubarLabelProps extends MenuLabelProps {}\n\nconst MenubarLabel = React.forwardRef<MenubarLabelElement, MenubarLabelProps>(\n  (props: ScopedProps<MenubarLabelProps>, forwardedRef) => {\n    const { __scopeMenubar, ...labelProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.Label {...menuScope} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenubarItem';\n\ntype MenubarItemElement = React.ElementRef<typeof MenuPrimitive.Item>;\ntype MenuItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Item>;\ninterface MenubarItemProps extends MenuItemProps {}\n\nconst MenubarItem = React.forwardRef<MenubarItemElement, MenubarItemProps>(\n  (props: ScopedProps<MenubarItemProps>, forwardedRef) => {\n    const { __scopeMenubar, ...itemProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.Item {...menuScope} {...itemProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenubarCheckboxItem';\n\ntype MenubarCheckboxItemElement = React.ElementRef<typeof MenuPrimitive.CheckboxItem>;\ntype MenuCheckboxItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.CheckboxItem>;\ninterface MenubarCheckboxItemProps extends MenuCheckboxItemProps {}\n\nconst MenubarCheckboxItem = React.forwardRef<MenubarCheckboxItemElement, MenubarCheckboxItemProps>(\n  (props: ScopedProps<MenubarCheckboxItemProps>, forwardedRef) => {\n    const { __scopeMenubar, ...checkboxItemProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.CheckboxItem {...menuScope} {...checkboxItemProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenubarRadioGroup';\n\ntype MenubarRadioGroupElement = React.ElementRef<typeof MenuPrimitive.RadioGroup>;\ntype MenuRadioGroupProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioGroup>;\ninterface MenubarRadioGroupProps extends MenuRadioGroupProps {}\n\nconst MenubarRadioGroup = React.forwardRef<MenubarRadioGroupElement, MenubarRadioGroupProps>(\n  (props: ScopedProps<MenubarRadioGroupProps>, forwardedRef) => {\n    const { __scopeMenubar, ...radioGroupProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.RadioGroup {...menuScope} {...radioGroupProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenubarRadioItem';\n\ntype MenubarRadioItemElement = React.ElementRef<typeof MenuPrimitive.RadioItem>;\ntype MenuRadioItemProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioItem>;\ninterface MenubarRadioItemProps extends MenuRadioItemProps {}\n\nconst MenubarRadioItem = React.forwardRef<MenubarRadioItemElement, MenubarRadioItemProps>(\n  (props: ScopedProps<MenubarRadioItemProps>, forwardedRef) => {\n    const { __scopeMenubar, ...radioItemProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.RadioItem {...menuScope} {...radioItemProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'MenubarItemIndicator';\n\ntype MenubarItemIndicatorElement = React.ElementRef<typeof MenuPrimitive.ItemIndicator>;\ntype MenuItemIndicatorProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.ItemIndicator>;\ninterface MenubarItemIndicatorProps extends MenuItemIndicatorProps {}\n\nconst MenubarItemIndicator = React.forwardRef<\n  MenubarItemIndicatorElement,\n  MenubarItemIndicatorProps\n>((props: ScopedProps<MenubarItemIndicatorProps>, forwardedRef) => {\n  const { __scopeMenubar, ...itemIndicatorProps } = props;\n  const menuScope = useMenuScope(__scopeMenubar);\n  return <MenuPrimitive.ItemIndicator {...menuScope} {...itemIndicatorProps} ref={forwardedRef} />;\n});\n\nMenubarItemIndicator.displayName = INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenubarSeparator';\n\ntype MenubarSeparatorElement = React.ElementRef<typeof MenuPrimitive.Separator>;\ntype MenuSeparatorProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Separator>;\ninterface MenubarSeparatorProps extends MenuSeparatorProps {}\n\nconst MenubarSeparator = React.forwardRef<MenubarSeparatorElement, MenubarSeparatorProps>(\n  (props: ScopedProps<MenubarSeparatorProps>, forwardedRef) => {\n    const { __scopeMenubar, ...separatorProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.Separator {...menuScope} {...separatorProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenubarArrow';\n\ntype MenubarArrowElement = React.ElementRef<typeof MenuPrimitive.Arrow>;\ntype MenuArrowProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.Arrow>;\ninterface MenubarArrowProps extends MenuArrowProps {}\n\nconst MenubarArrow = React.forwardRef<MenubarArrowElement, MenubarArrowProps>(\n  (props: ScopedProps<MenubarArrowProps>, forwardedRef) => {\n    const { __scopeMenubar, ...arrowProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return <MenuPrimitive.Arrow {...menuScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenubarArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenubarSub';\n\ninterface MenubarSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenubarSub: React.FC<MenubarSubProps> = (props: ScopedProps<MenubarSubProps>) => {\n  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;\n  const menuScope = useMenuScope(__scopeMenubar);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n\n  return (\n    <MenuPrimitive.Sub {...menuScope} open={open} onOpenChange={setOpen}>\n      {children}\n    </MenuPrimitive.Sub>\n  );\n};\n\nMenubarSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenubarSubTrigger';\n\ntype MenubarSubTriggerElement = React.ElementRef<typeof MenuPrimitive.SubTrigger>;\ntype MenuSubTriggerProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.SubTrigger>;\ninterface MenubarSubTriggerProps extends MenuSubTriggerProps {}\n\nconst MenubarSubTrigger = React.forwardRef<MenubarSubTriggerElement, MenubarSubTriggerProps>(\n  (props: ScopedProps<MenubarSubTriggerProps>, forwardedRef) => {\n    const { __scopeMenubar, ...subTriggerProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n    return (\n      <MenuPrimitive.SubTrigger\n        data-radix-menubar-subtrigger=\"\"\n        {...menuScope}\n        {...subTriggerProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenubarSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenubarSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenubarSubContent';\n\ntype MenubarSubContentElement = React.ElementRef<typeof MenuPrimitive.Content>;\ntype MenuSubContentProps = Radix.ComponentPropsWithoutRef<typeof MenuPrimitive.SubContent>;\ninterface MenubarSubContentProps extends MenuSubContentProps {}\n\nconst MenubarSubContent = React.forwardRef<MenubarSubContentElement, MenubarSubContentProps>(\n  (props: ScopedProps<MenubarSubContentProps>, forwardedRef) => {\n    const { __scopeMenubar, ...subContentProps } = props;\n    const menuScope = useMenuScope(__scopeMenubar);\n\n    return (\n      <MenuPrimitive.SubContent\n        {...menuScope}\n        data-radix-menubar-content=\"\"\n        {...subContentProps}\n        ref={forwardedRef}\n        style={{\n          ...props.style,\n          // re-namespace exposed content custom properties\n          ...{\n            '--radix-menubar-content-transform-origin': 'var(--radix-popper-transform-origin)',\n            '--radix-menubar-content-available-width': 'var(--radix-popper-available-width)',\n            '--radix-menubar-content-available-height': 'var(--radix-popper-available-height)',\n            '--radix-menubar-trigger-width': 'var(--radix-popper-anchor-width)',\n            '--radix-menubar-trigger-height': 'var(--radix-popper-anchor-height)',\n          },\n        }}\n      />\n    );\n  }\n);\n\nMenubarSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = Menubar;\nconst Menu = MenubarMenu;\nconst Trigger = MenubarTrigger;\nconst Portal = MenubarPortal;\nconst Content = MenubarContent;\nconst Group = MenubarGroup;\nconst Label = MenubarLabel;\nconst Item = MenubarItem;\nconst CheckboxItem = MenubarCheckboxItem;\nconst RadioGroup = MenubarRadioGroup;\nconst RadioItem = MenubarRadioItem;\nconst ItemIndicator = MenubarItemIndicator;\nconst Separator = MenubarSeparator;\nconst Arrow = MenubarArrow;\nconst Sub = MenubarSub;\nconst SubTrigger = MenubarSubTrigger;\nconst SubContent = MenubarSubContent;\n\nexport {\n  createMenubarScope,\n  //\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarPortal,\n  MenubarContent,\n  MenubarGroup,\n  MenubarLabel,\n  MenubarItem,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarItemIndicator,\n  MenubarSeparator,\n  MenubarArrow,\n  MenubarSub,\n  MenubarSubTrigger,\n  MenubarSubContent,\n  //\n  Root,\n  Menu,\n  Trigger,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenubarProps,\n  MenubarMenuProps,\n  MenubarTriggerProps,\n  MenubarPortalProps,\n  MenubarContentProps,\n  MenubarGroupProps,\n  MenubarLabelProps,\n  MenubarItemProps,\n  MenubarCheckboxItemProps,\n  MenubarRadioGroupProps,\n  MenubarRadioItemProps,\n  MenubarItemIndicatorProps,\n  MenubarSeparatorProps,\n  MenubarArrowProps,\n  MenubarSubProps,\n  MenubarSubTriggerProps,\n  MenubarSubContentProps,\n};\n"],
  "mappings": "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",
  "names": ["SELECTION_KEYS", "FIRST_KEYS", "LAST_KEYS", "FIRST_LAST_KEYS", "SUB_OPEN_KEYS", "ltr", "rtl", "SUB_CLOSE_KEYS", "MENU_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createMenuContext", "createMenuScope", "createContextScope", "createPopperScope", "createRovingFocusGroupScope", "usePopperScope", "useRovingFocusGroupScope", "MenuProvider", "useMenuContext", "MenuRootProvider", "useMenuRootContext", "Menu", "props", "modal", "popperScope", "__scopeMenu", "content", "setContent", "React", "isUsingKeyboardRef", "handleOpenChange", "useCallbackRef", "onOpenChange", "direction", "useDirection", "dir", "handleKeyDown", "current", "document", "addEventListener", "handlePointer", "capture", "once", "removeEventListener", "$epM9y$createElement", "children", "ANCHOR_NAME", "MenuAnchor", "forwardedRef", "anchorProps", "PORTAL_NAME", "PortalProvider", "usePortalContext", "forceMount", "undefined", "MenuPortal", "container", "context", "open", "CONTENT_NAME", "MenuContentProvider", "useMenuContentContext", "MenuContent", "portalContext", "contentProps", "rootContext", "MenuRootContentModal", "ref", "composedRefs", "useComposedRefs", "hideOthers", "composeEventHandlers", "onFocusOutside", "event", "preventDefault", "checkForDefaultPrevented", "MenuRootContentNonModal", "MenuContentImpl", "rovingFocusGroupScope", "getItems", "currentItemId", "setCurrentItemId", "contentRef", "onContentChange", "timerRef", "searchRef", "pointerGraceTimerRef", "pointerGraceIntentRef", "pointerDirRef", "lastPointerXRef", "ScrollLockWrapper", "disableOutsideScroll", "RemoveScroll", "scrollLockWrapperProps", "as", "Slot", "allowPinchZoom", "handleTypeaheadSearch", "key", "search", "items", "filter", "item", "disabled", "currentItem", "activeElement", "currentMatch", "find", "textValue", "values", "map", "nextMatch", "getNextMatch", "newItem", "updateSearch", "value", "window", "clearTimeout", "setTimeout", "focus", "useFocusGuards", "isPointerMovingToSubmenu", "isMovingTowards", "side", "isPointerInGraceArea", "area", "intent", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "onEntryFocus", "getOpenState", "outline", "style", "onKeyDown", "target", "isKeyDownInside", "closest", "currentTarget", "isModifierKey", "ctrlKey", "altKey", "metaKey", "isCharacterKey", "length", "includes", "candidateNodes", "reverse", "focusFirst", "onBlur", "contains", "onPointerMove", "whenMouse", "pointerXHasChanged", "clientX", "newDir", "GROUP_NAME", "MenuGroup", "groupProps", "LABEL_NAME", "MenuLabel", "labelProps", "ITEM_NAME", "ITEM_SELECT", "MenuItem", "itemProps", "contentContext", "isPointerDownRef", "handleSelect", "menuItem", "itemSelectEvent", "CustomEvent", "bubbles", "cancelable", "onSelect", "dispatchDiscreteCustomEvent", "defaultPrevented", "onClose", "onClick", "onPointerDown", "onPointerUp", "click", "isTypingAhead", "MenuItemImpl", "isFocused", "setIsFocused", "textContent", "setTextContent", "trim", "onItemLeave", "onItemEnter", "onPointerLeave", "onFocus", "CHECKBOX_ITEM_NAME", "MenuCheckboxItem", "checkboxItemProps", "isIndeterminate", "checked", "getCheckedState", "onCheckedChange", "RADIO_GROUP_NAME", "RadioGroupProvider", "useRadioGroupContext", "onValueChange", "MenuRadioGroup", "handleValueChange", "RADIO_ITEM_NAME", "MenuRadioItem", "radioItemProps", "ITEM_INDICATOR_NAME", "ItemIndicatorProvider", "useItemIndicatorContext", "MenuItemIndicator", "itemIndicatorProps", "indicatorContext", "SEPARATOR_NAME", "MenuSeparator", "separatorProps", "ARROW_NAME", "MenuArrow", "arrowProps", "SUB_NAME", "MenuSubProvider", "useMenuSubContext", "MenuSub", "parentMenuContext", "trigger", "setTrigger", "useId", "SUB_TRIGGER_NAME", "MenuSubTrigger", "subContext", "openTimerRef", "onPointerGraceIntentChange", "scope", "clearOpenTimer", "pointerGraceTimer", "triggerId", "contentId", "composeRefs", "onTriggerChange", "contentRect", "getBoundingClientRect", "dataset", "rightSide", "bleed", "contentNearEdge", "contentFarEdge", "x", "y", "clientY", "top", "bottom", "onTriggerLeave", "SUB_CONTENT_NAME", "MenuSubContent", "subContentProps", "onEscapeKeyDown", "isCloseKey", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "candidate", "wrapArray", "array", "startIndex", "_", "index", "isRepeated", "Array", "from", "every", "char", "normalizedSearch", "currentMatchIndex", "indexOf", "wrappedValues", "Math", "max", "excludeCurrentMatch", "v", "toLowerCase", "startsWith", "isPointInPolygon", "point", "polygon", "inside", "i", "j", "xi", "yi", "xj", "yj", "intersect", "cursorPos", "handler", "pointerType", "Root", "Anchor", "Portal", "Content", "Group", "Label", "Item", "CheckboxItem", "RadioGroup", "RadioItem", "ItemIndicator", "Separator", "Arrow", "Sub", "SubTrigger", "SubContent", "MENUBAR_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createMenubarContext", "createMenubarScope", "createContextScope", "createRovingFocusGroupScope", "useMenuScope", "createMenuScope", "useRovingFocusGroupScope", "MenubarContextProvider", "useMenubarContext", "Menubar", "React", "props", "forwardedRef", "value", "valueProp", "menubarProps", "direction", "useDirection", "dir", "rovingFocusGroupScope", "__scopeMenubar", "setValue", "useControllableState", "prop", "onChange", "onValueChange", "defaultProp", "defaultValue", "currentTabStopId", "setCurrentTabStopId", "$jLgaT$createElement", "prevValue", "Boolean", "MENU_NAME", "MenubarMenuProvider", "useMenubarMenuContext", "MenubarMenu", "menuProps", "autoValue", "useId", "context", "menuScope", "triggerRef", "wasKeyboardTriggerOpenRef", "open", "current", "onMenuClose", "TRIGGER_NAME", "MenubarTrigger", "triggerProps", "menuContext", "ref", "composedRefs", "useComposedRefs", "isFocused", "setIsFocused", "disabled", "triggerId", "contentId", "undefined", "composeEventHandlers", "onPointerDown", "event", "button", "ctrlKey", "onMenuOpen", "preventDefault", "onPointerEnter", "menubarOpen", "focus", "onKeyDown", "includes", "key", "onMenuToggle", "onFocus", "onBlur", "PORTAL_NAME", "MenubarPortal", "portalProps", "CONTENT_NAME", "MenubarContent", "contentProps", "getItems", "hasInteractedOutsideRef", "onCloseAutoFocus", "onFocusOutside", "target", "isMenubarTrigger", "some", "item", "contains", "onInteractOutside", "targetIsSubTrigger", "hasAttribute", "isKeyDownInsideSubMenu", "closest", "currentTarget", "prevMenuKey", "isPrevKey", "isNextKey", "items", "filter", "candidateValues", "map", "reverse", "currentIndex", "indexOf", "loop", "wrapArray", "slice", "nextValue", "checkForDefaultPrevented", "style", "GROUP_NAME", "MenubarGroup", "groupProps", "LABEL_NAME", "MenubarLabel", "labelProps", "ITEM_NAME", "MenubarItem", "itemProps", "CHECKBOX_ITEM_NAME", "MenubarCheckboxItem", "checkboxItemProps", "RADIO_GROUP_NAME", "MenubarRadioGroup", "radioGroupProps", "RADIO_ITEM_NAME", "MenubarRadioItem", "radioItemProps", "INDICATOR_NAME", "MenubarItemIndicator", "itemIndicatorProps", "SEPARATOR_NAME", "MenubarSeparator", "separatorProps", "ARROW_NAME", "MenubarArrow", "arrowProps", "SUB_NAME", "MenubarSub", "openProp", "defaultOpen", "setOpen", "onOpenChange", "children", "SUB_TRIGGER_NAME", "MenubarSubTrigger", "subTriggerProps", "SUB_CONTENT_NAME", "MenubarSubContent", "subContentProps", "array", "startIndex", "_", "index", "length", "Root", "Menu", "Trigger", "Portal", "Content", "Group", "Label", "Item", "CheckboxItem", "RadioGroup", "RadioItem", "ItemIndicator", "Separator", "Arrow", "Sub", "SubTrigger", "SubContent"]
}
